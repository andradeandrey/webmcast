import '/json'
import '/inspect'


_encode = json.JSONEncoder!.encode
_decode = json.JSONDecoder!.decode
_M = **: xs -> xs


Client = subclass object where
    __init__ = self io context loop ->
        self.io      = io
        self.context = context
        self.loop    = loop
        None

    __enter__ = self ->
        self.io.__enter__!
        self.context.__connect__ self
        self

    __exit__ = self t v tb ->
        self.context.__disconnect__ self
        self.io.__exit__ t v tb
        None

    emit = self method *: args ->
        self.io.send $ _encode $ _M jsonrpc: '2.0' method: method params: args

    respond = self id result ->
        self.io.send $ _encode $ _M jsonrpc: '2.0' id: id result: result

    error = self id code message ->
        self.io.send $ _encode $ _M jsonrpc: '2.0' id: id error: (_M code: code message: message)

    run = async $ self ->
        tasks = {}
        task_done = task ->
            id = tasks.pop task
            if task.exception! is None => self.respond id task.result!
               task.cancelled!         => self.error id 0 'cancelled'
               otherwise               => self.error id 0 $ str task.exception!

        except
            _ => async for msg in self.io =>
                len msg > 65535 =>
                    return self.error None -32700 'message too long'
                except
                    err =>
                        req = _decode msg
                        id, func, args = req !! 'id', req !! 'method', req !! 'params'
                    err :: Exception =>
                        self.error None -32700 'parse error'
                    err is None => except
                        err =>
                            coro, r = self.context self func args
                            if not coro  => self.respond id r
                               otherwise =>
                                task = self.loop.create_task r
                                task.add_done_callback task_done
                                tasks !! task = id
                        err :: Exception =>
                            self.error id 0 $ str err
            finally =>
                for task in tasks => task.cancel!


Context = subclass object where
    __call__ = self rpc method args ->
        not $ args :: list =>
            raise TypeError 'non-positional arguments not supported'
        method.startswith '_' =>
            raise NameError 'invalid method name'
        f = except err => getattr self method
                   err :: AttributeError => raise NameError 'unknown method'
        inspect.iscoroutinefunction f, f rpc *: args
