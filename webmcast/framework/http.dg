import '/os'
import '/time'
import '/zlib'
import '/asyncio'
import '/mimetypes'
import '/posixpath'
import '/contextlib'
import '/urllib/parse/unquote'

import '/cno'

_websocket = import 'websocket' pure


_SyncFileIterator = subclass object where
    __init__  = self self.fd -> None
    __aiter__ = async $ self -> self
    __anext__ = async $ self -> self.fd.read 8192 or raise StopAsyncIteration


_Compressor = subclass object where
    __init__ = self data ->
        self.gz = zlib.compressobj wbits: 31
        self.it = data.__aiter__!
        self.done = False
        None

    __aiter__ = async $ self ->
        self.it = await self.it
        self

    __anext__ = async $ self ->
        self.done => raise StopAsyncIteration
        except
            err => self.gz.compress $ await self.it.__anext__!
            err :: StopAsyncIteration =>
                self.done = True
                self.gz.flush!


_compress = data -> if
    data :: bytes =>
        gz = zlib.compressobj wbits: 31
        gz.compress data + gz.flush!
    otherwise => _Compressor data


_rfc1123 = ts ->
    Y, m, d, H, M, S, w, _, _ = time.gmtime ts
    a = ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun')
    b = ('---', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')
    '%s, %02d %s %04d %02d:%02d:%02d GMT' % (a !! w, m, b !! m, Y, H, M, S)


Request = subclass cno.Request where
    render = self _name **: kwargs ->
        self.template _name |>.render request: self **: kwargs

    respond_with_gzip = async $ self code headers data ->
        for (k, v) in self.accept_headers =>
            if k == 'accept-encoding' and 'gzip' in v =>
                headers = headers + [('content-encoding', 'gzip')]
                return await self.respond code headers $ _compress data
        return await self.respond code headers data

    respond_with_template = async $ self code headers name **: kwargs ->
        self.render name **: kwargs |>.encode 'utf-8' |> await self.respond_with_gzip code headers

    respond_with_error = async $ self code headers message **: kwargs ->
        headers = headers + [('cache-control', 'no-cache')]
        payload = except
            e => self.render 'error' code: code message: message **: kwargs
            e :: Exception =>
                self.conn.loop.call_exception_handler $ dict'
                    'message', 'error while rendering error page'
                    'exception', e
                'error {}: {}'.format code message
        except
            e => await self.respond_with_gzip code headers $ payload.encode 'utf-8'
            e :: ConnectionError => self.cancel!

    respond_with_file = async $ self path headers: [] cacheable: True ->
        self.method in ('GET', 'HEAD') or
            return await self.respond_with_error 405 [] 'This resource is static.'
        # i'd serve everything as application/octet-stream, but then browsers
        # refuse to use these files as stylesheets/scripts.
        mime = mimetypes.guess_type path False !! 0 or 'application/octet-stream'
        except
            err =>
                # `path` expected to be in normal form (no `.`/`..`)
                fd = open path 'rb' buffering: 8192
                headers = headers + if
                    cacheable => list'
                        'last-modified', _rfc1123 (os.stat fd.fileno!).st_mtime
                        'cache-control', 'private, max-age=31536000'
                        'content-type', mime
                    otherwise => list'
                        'content-type', mime
            err :: IOError =>
                return await self.respond_with_error 404 [] None
        await self.respond_with_gzip 200 headers $ _SyncFileIterator fd

    websocket = async $ self ->
        fail = self.conn.is_http2 or self.method != 'GET' or
               (self.header_map.get 'upgrade').lower! != 'websocket' or
                self.header_map.get 'sec-websocket-version' != '13' or
                 not $ 'sec-websocket-key' in self.header_map
        fail =>
            await self.respond_with_error 400 [] 'WebSocket handshake failed.'
            raise _websocket.ProtocolError 'invalid handshake'

        await self.respond 101
            list'
                'upgrade', 'websocket'
                'connection', 'upgrade'
                'sec-websocket-accept', _websocket.accept $ self.header_map !! 'sec-websocket-key'
            b''
        reader = asyncio.StreamReader loop: self.conn.loop
        self.conn.data_received = reader.feed_data
        self.conn.eof_received  = reader.feed_eof
        return _websocket.Socket self.conn.loop reader self.conn.transport


server = async $ loop root *: args **: kwargs ->
    handle = async $ req ->
        req.__class__ = Request
        req.path, _, req.query = req.path.partition '?'
        req.path = posixpath.normpath $ '///' + unquote req.path
        req.header_map = dict req.headers
        req.accept_headers = list (where for (k, v) in req.headers =>
            if k.startswith 'accept' => yield (k, v))
        except err => await root req
               err :: asyncio.CancelledError => raise err
               err :: Exception =>
                  req.conn.loop.call_exception_handler $ dict'
                      'message', 'error in request handler'
                      'exception', err
                  await req.respond_with_error 500 [] 'This is an error-handling message.'
    return await loop.create_server (-> cno.Server loop handle) *: args **: kwargs
