import '/os'
import '/time'
import '/zlib'
import '/asyncio'
import '/mimetypes'
import '/posixpath'
import '/urllib/parse/unquote'

import '/cno'

_websocket = import 'websocket' pure


_read_file_to_queue = async $ fd queue -> except
    _ =>
        while data = fd.read 8192 =>
            await queue.put data
    finally => queue.close!


_compress_into_queue = async $ data queue -> except
    _ =>
        gz = zlib.compressobj wbits: 31
        if data :: bytes => await queue.put $ gz.compress data
           data :: cno.Channel =>
            async for chunk in data =>
                await queue.put $ gz.compress chunk
           otherwise => raise TypeError 'unsupported data type'
        await queue.put gz.flush!
    finally => queue.close!


_rfc1123 = ts ->
    Y, m, d, H, M, S, w, _, _ = time.gmtime ts
    a = ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun')
    b = ('---', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec')
    '%s, %02d %s %04d %02d:%02d:%02d GMT' % (a !! w, m, b !! m, Y, H, M, S)


Request = subclass cno.Request where
    render = self _name **: kwargs ->
        self.template _name |>.render request: self **: kwargs

    respond_with_gzip = async $ self code headers data ->
        found = for (k, v) in self.accept_headers =>
            if k == 'accept-encoding' and 'gzip' in v =>
                break!
        not found =>
            return await self.respond code headers data

        headers = headers + [('content-encoding', 'gzip')]
        ch = cno.Channel loop: self.conn.loop
        writer = self.conn.loop.create_task $ _compress_into_queue data ch
        except
            _ => await self.respond code headers ch
            finally => writer.cancel!

    respond_with_template = async $ self code headers name **: kwargs ->
        self.render name **: kwargs |>.encode 'utf-8' |> await self.respond_with_gzip code headers

    respond_with_error = async $ self code headers message **: kwargs ->
        headers = headers + [('cache-control', 'no-cache')]
        payload = except
            e => self.render 'error' code: code message: message **: kwargs
            e :: Exception =>
                self.conn.loop.call_exception_handler $ dict'
                    'message', 'error while rendering error page'
                    'exception', e
                'error {}: {}'.format code message
        except
            e => await self.respond_with_gzip code headers $ payload.encode 'utf-8'
            e :: ConnectionError => self.cancel!

    respond_with_file = async $ self path headers: [] cacheable: True ->
        self.method in ('GET', 'HEAD') or
            return await self.respond_with_error 405 [] 'This resource is static.'
        # i'd serve everything as application/octet-stream, but then browsers
        # refuse to use these files as stylesheets/scripts.
        mime = mimetypes.guess_type path False !! 0 or 'application/octet-stream'
        except
            err =>
                # `path` expected to be in normal form (no `.`/`..`)
                fd = open path 'rb' buffering: 8192
                headers = headers + if
                    cacheable => list'
                        'last-modified', _rfc1123 (os.stat fd.fileno!).st_mtime
                        'cache-control', 'private, max-age=31536000'
                        'content-type', mime
                    otherwise => list'
                        'content-type', mime
            err :: IOError =>
                return await self.respond_with_error 404 [] None
        ch = cno.Channel 1 loop: self.conn.loop
        writer = self.conn.loop.create_task $ _read_file_to_queue fd ch
        except
            _ =>
                await self.respond_with_gzip 200 headers ch
            finally =>
                writer.cancel!
                fd.close!

    websocket = async $ self ->
        fail = self.conn.is_http2 or self.method != 'GET' or
               (self.header_map.get 'upgrade').lower! != 'websocket' or
                self.header_map.get 'sec-websocket-version' != '13' or
                 not $ 'sec-websocket-key' in self.header_map
        fail =>
            await self.respond_with_error 400 [] 'WebSocket handshake failed.'
            raise _websocket.ProtocolError 'invalid handshake'

        await self.respond 101
            list'
                'upgrade', 'websocket'
                'connection', 'upgrade'
                'sec-websocket-accept', _websocket.accept $ self.header_map !! 'sec-websocket-key'
            b''
        reader = asyncio.StreamReader loop: self.conn.loop
        self.conn.data_received = reader.feed_data
        self.conn.eof_received  = reader.feed_eof
        return _websocket.Socket self.conn.loop reader self.conn.transport


server = async $ loop root *: args **: kwargs ->
    handle = async $ req ->
        req.__class__ = Request
        req.path, _, req.query = req.path.partition '?'
        req.path = posixpath.normpath $ '///' + unquote req.path
        req.header_map = dict req.headers
        req.accept_headers = list $ filter ((k, _) -> k.startswith 'accept') req.headers
        except err => await root req
               err :: asyncio.CancelledError => raise err
               err :: Exception =>
                  req.conn.loop.call_exception_handler $ dict'
                      'message', 'error in request handler'
                      'exception', err
                  await req.respond_with_error 500 [] 'This is an error-handling message.'
    return await loop.create_server (-> cno.Server loop handle) *: args **: kwargs
