import '/os'
import '/time'
import '/zlib'
import '/asyncio'
import '/mimetypes'
import '/posixpath'
import '/urllib/parse/unquote'

import '/cno'

_websocket = import 'websocket' pure


io_payload = subclass object where
    __init__  = self self.fd -> None
    __aiter__ = async $ self -> self
    __anext__ = async $ self -> self.fd.read 8192 or raise StopAsyncIteration


compress = data -> if
    data :: bytes =>
        gz = zlib.compressobj wbits: 31
        gz.compress data + gz.flush!
    otherwise => _compress_iterable data.__aiter__! $ zlib.compressobj wbits: 31


_compress_iterable = subclass object where
    __init__ = self self.it self.gz -> None

    __aiter__ = async $ self ->
        self.it = await self.it
        self

    __anext__ = async $ self ->
        if self.it is None => raise StopAsyncIteration
        except
            err => self.gz.compress $ await self.it.__anext__!
            err :: StopAsyncIteration =>
                self.it = None
                self.gz.flush!


date_header = ts ->  # RFC 1123
    Y, m, d, H, M, S, w, _, _ = time.gmtime ts
    a = 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'
    b = '---', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    '%s, %02d %s %04d %02d:%02d:%02d GMT' % (a !! w, d, b !! m, Y, H, M, S)


Request = subclass cno.Request where
    render = self _name **: kwargs ->
        self.template _name |>.render request: self **: kwargs

    respond_with_gzip = async $ self code headers data ->
        if 'gzip' in self.header_map.get 'accept-encoding' '' =>
            headers = headers + [('content-encoding', 'gzip')]
            return await self.respond code headers $ compress data
        return await self.respond code headers data

    respond_with_template = async $ self code headers name **: kwargs ->
        self.render name **: kwargs |>.encode 'utf-8' |> await self.respond_with_gzip code headers

    respond_with_error = async $ self code headers message **: kwargs ->
        headers = headers + [('cache-control', 'no-cache')]
        payload = except
            e => self.render 'error' code: code message: message **: kwargs
            e :: Exception =>
                self.conn.loop.call_exception_handler $ dict'
                    'message', 'error while rendering error page'
                    'exception', e
                'error {}: {}'.format code message
        except
            e => await self.respond_with_gzip code headers $ payload.encode 'utf-8'
            e :: ConnectionError => self.cancel!

    respond_with_file = async $ self path headers: [] cacheable: True ->
        self.method in ('GET', 'HEAD') or
            return await self.respond_with_error 405 [('allow', 'GET')] 'This resource is static.'
        file = except
            err =>
                open path 'rb' buffering: 8192
            err :: IOError =>
                return await self.respond_with_error 404 [] None
        # i'd serve everything as application/octet-stream, but then browsers
        # refuse to use these files as stylesheets/scripts.
        mime = mimetypes.guess_type path False !! 0 or 'application/octet-stream'
        headers = headers + if
            cacheable => list'
                'last-modified', os.stat file.fileno! |>.st_mtime |> date_header
                'cache-control', 'private, max-age=31536000'
                'content-type', mime
            otherwise => list'
                'content-type', mime
        return await self.respond_with_gzip 200 headers $ io_payload file

    wants_websocket = property $ self ->
        (self.header_map.get 'upgrade' '').lower! == 'websocket'

    websocket = async $ self ->
        if ((or) self.conn.is_http2
                 not self.wants_websocket
                 self.method != 'GET'
                 self.header_map.get 'sec-websocket-version' != '13'
                 self.header_map.get 'sec-websocket-key' is None
        ) =>
            await self.respond_with_error 400 [] 'WebSocket handshake failed.'
            raise _websocket.ProtocolError 'invalid handshake'

        await self.respond 101
            list'
                'upgrade', 'websocket'
                'connection', 'upgrade'
                'sec-websocket-accept', _websocket.accept $ self.header_map !! 'sec-websocket-key'
            b''
        reader = asyncio.StreamReader loop: self.conn.loop
        socket = _websocket.Socket self.conn.loop reader self.conn.transport
        self.conn.data_received  = reader.feed_data
        self.conn.eof_received   = reader.feed_eof
        self.conn.pause_writing  = socket.pause_writing
        self.conn.resume_writing = socket.resume_writing
        return socket


server = async $ loop root *: args **: kwargs ->
    handle = async $ req ->
        req.__class__ = Request
        req.path, _, req.query = req.path.partition '?'
        req.path = posixpath.normpath $ '///' + unquote req.path
        req.header_map = dict req.headers
        req.accept_headers = list (where for (k, v) in req.headers =>
            if k.startswith 'accept' => yield (k, v))
        except err => await root req
               err :: asyncio.CancelledError => raise err
               err :: Exception =>
                  req.conn.loop.call_exception_handler $ dict'
                      'message', 'error in request handler'
                      'exception', err
                  await req.respond_with_error 500 [] 'This is an error-handling message.'
    return await loop.create_server (-> cno.Server loop handle) *: args **: kwargs
